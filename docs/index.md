# How to Detect if that Flappy Bird Knock-off is Actually A Trojan Selling Your Data to the Deep Web
### Also Known As 
### My 2016 Summer Internship


## The Problem

My research problem in summer 2016 was to explore a dataset of a full Android app code package and a binary label of whether the app is malware or not. The main goal was to figure out how to make the best classifier from the data. 

It was a very open-ended problem, and I ended up focusing on a a) a data science perspective of what markers signify malware and semantically how it all fits together and b) how to improve on other models in the research literature by making the classifier more suitable for practical application.

## Learning More about the Domain Area

I read academic research papers to get a better idea of the domain, as that was a good way to gather in-depth information without dealing with proprietary boundaries or marketing. 

Two approaches stood out: 

One was the DREBIN program of 2014. By 2016 DREBIN was the gold standard of this domain. It was possible to use DREBIN on the Android OS itself. It would add 10 seconds of checking the newly downloaded Android app before making its prediction, a theoretically small price to pay for peace of mind (to computer security researchers, at least). It detected 94% of malware in its dataset with a false-positive rate of 1% and an unnamed false-negative rate (I would heavily favor reducing false positives to false negatives in this problem area too, considering it's impossible to un-share/sell your data once it is leaked). It also by far outperformed commercial virus scanners which did not specialize in Android apps. 

I decided to follow their approach of using a support vector machine to classify the apps. They made the feature space as-large-as-possible by taking features from the Android app manifest file and from parsing the Android app bytecode file that is the app's program logic itself.

The other program I found interesting was ICCDetector, which specialized even further in this problem domain. It specialized in inter-app communication to find apps that took advantage of general phone events to make their move, so to speak. ICCDetector also used a support vector machine.

## My Approach

Going into my model building, I knew that support vector machines worked well for these type of problems. I knew I wanted to include features from the Android app manifest file, because it is a single file access with straighforward parsing and for the known virus families they all requested certain permissions through the Android app manifest file. I also knew that I wanted my approach to be faster than ten seconds per app. My entire approach became stripping away features that added to the feature extraction runtime and seeing the impact on accuracy.

## Semantic Findings 

I wanted t

## Comparing Different Machine Learning Algorithms on Overall Feature Space

For my own edification

## Impact

This project shows that it is possible to strip the program logic parsing of an Android app and still have a good accuracy in determining if it is malicious. The DREBIN and ICCDetector models were not truly logic analysis understanding so much as searching for key words in how the app decides to run actions and call on other apps.

## Helpful Resources

This is [the official conference paper](nyit-malware/MONICAKUMARAN_REUPAPER_ieeformat.pdf) I wrote.

I found this [article (link stable on 8/9/21)](https://medium.com/androiddevnotes/the-internals-of-android-apk-build-process-article-5b68c385fb20) useful for understanding the Android app file structure.